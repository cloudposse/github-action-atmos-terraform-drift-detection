name: 'GitHub Action Atmos Terraform Drift Detection'
description: 'GitHub Action Atmos Terraform Drift Detection'
author: hello@cloudposse.com
branding:
  icon: 'server'
  color: 'white'
inputs:
  issue-labels:
    description: "Comma separated list of labels to add to the drift issues. Default: drift"
    default: 'drift'
    required: false
  max-opened-issues:
    description: "Number of open drift detection issues. Use `-1` to open unlimited number of issues. Default: 10"
    default: '10'
    required: false
  assignee-users:
    description: "Comma-separated list of users to assign issues to. This is used only when issue is getting created."
    required: false
    default: ""
  assignee-teams:
    description: "Comma-separated list of teams to assign issues to. You have to pass github token with `read:org` scope. This is used only when issue is getting created."
    required: false
    default: ""
  debug:
    description: "Enable action debug mode. Default: false"
    default: 'false'
    required: false
  token:
    description:
      Used to pull node distributions for Atmos from Cloud Posse's GitHub repository. Since there's a default, this is typically
      not supplied by the user. When running this action on github.com, the default value is sufficient. When running on
      GHES, you can pass a personal access token for github.com if you are experiencing rate limiting.
    default: ${{ github.server_url == 'https://github.com' && github.token || '' }}
outputs:
  components-with-issues:
    description: A matrix for components that have issues
    value: ${{ steps.lookup-issues.outputs.components-with-issues }}
  components-without-issues:
    description: A matrix for components that do not have issues
    value: ${{ steps.lookup-issues.outputs.components-without-issues }}

runs:
  using: "composite"
  steps:
    - name: Download Artifacts
      uses: actions/download-artifact@v3
      with:
        name: metadata

    - name: Get Drift Detection GitHub Issues
      id: drift-detection-issues
      uses: actions/github-script@v6
      with:
        github-token: ${{ inputs.token }}
        script: |
          const repository = context.repo;

          let per_page = 100; // Max allowed value
          let page = 1;
          let componentsToIssues = {};
          let componentsToMetadata = {};
          let isContinue = true;

          function getMetadataFromIssueBody(body) {
            const regex = /```json\s([\s\S]+?)\s```/;
            const matched = body.match(regex);

            if (matched && matched[1]) {
              return JSON.parse(matched[1]);
            } else {
              throw new Error("Invalid metadata in the issue description");
            }
          }

          while (isContinue) {
            const response = await github.rest.issues.listForRepo({
              ...repository,
              state: 'open',
              per_page,
              page
            });
            
            if (response.data.length === 0) {
              isContinue = false;
            } else {
              const driftDetectionIssues = response.data
                .filter(issue => issue.title.startsWith('Drift Detected in'));
              
              for (let issue of driftDetectionIssues) {
                const metadata = getMetadataFromIssueBody(issue.body);
                componentsToIssues[`${metadata.stack}-${metadata.component}`] = issue.number;
                componentsToMetadata[`${metadata.stack}-${metadata.component}`] = metadata;
              }

              page++;
            }
          }

          const componentsToIssuesSerialized = JSON.stringify(componentsToIssues);
          const componentsToMetadataSerialized = JSON.stringify(componentsToMetadata);

          console.log(`Components to Issues Map: ${componentsToIssuesSerialized}`);
          console.log(`Components to Metadata Map: ${componentsToMetadataSerialized}`);

          core.setOutput("components-to-issues-map", componentsToIssuesSerialized);
          core.setOutput("components-to-metadata-map", componentsToMetadataSerialized);

    - name: Read Metadata From Artifacts
      id: metadata-from-artifacts
      uses: actions/github-script@v6
      with:
        github-token: ${{ inputs.token }}
        script: |
          const fs = require('fs');

          const files = fs.readdirSync('.');
          const metadataFiles = files.filter(file => file.endsWith('metadata.json'));

          let componentsToState = {};
          let componentsToMetadata = {};

          for (let i = 0; i < metadataFiles.length; i++) {
            console.log(`Processing file ${metadataFiles[i]}`);

            const metadata = JSON.parse(fs.readFileSync(metadataFiles[i], 'utf8'));

            const slug = `${metadata.stack}-${metadata.component}`;
            const drifted = metadata.drifted;

            componentsToState[slug] = drifted;
            componentsToMetadata[slug] = metadata;
          }

          const componentsToStateSerialized = JSON.stringify(componentsToState);
          const componentsToMetadataSerialized = JSON.stringify(componentsToMetadata);

          console.log(`Components to State Map: ${componentsToStateSerialized}`);
          console.log(`Components to Metadata Map: ${componentsToMetadataSerialized}`);

          core.setOutput("components-to-state-map", componentsToStateSerialized);
          core.setOutput("components-to-metadata-map", componentsToMetadataSerialized);

    - name: Triage
      id: triage
      uses: actions/github-script@v6
      with:
        github-token: ${{ inputs.token }}
        script: |
          const componentsToIssuesMap = JSON.parse('${{ steps.drift-detection-issues.outputs.components-to-issues-map }}', 'utf8');
          const componentsToMetadataMap = JSON.parse('${{ steps.drift-detection-issues.outputs.components-to-metadata-map }}', 'utf8');
          const componentsToStateMap = JSON.parse('${{ steps.metadata-from-artifacts.outputs.components-to-state-map }}', 'utf8');

          let slugs = new Set([...Object.keys(componentsToIssuesMap), ...Object.keys(componentsToStateMap)]);

          const componentsToCreateIssues = [];
          const componentsToUpdateIssues = [];
          const removedComponents = [];
          const recoveredComponents = [];
          const driftingComponents = [];

          for (let slug of slugs) {
            if (componentsToIssuesMap.hasOwnProperty(slug)) {
              const issueNumber = componentsToIssuesMap[slug];

              if (componentsToStateMap.hasOwnProperty(slug)) {
                const drifted = componentsToStateMap[slug];

                if (drifted) {
                  const commitSHA = componentsToMetadataMap[slug].commitSHA;
                  const currentSHA = "${{ github.sha }}";
                  if (currentSHA === commitSHA) {
                    console.log(`Component "${slug}" marked as drifted but default branch SHA didn't change so nothing to update. Skipping ...`);
                    driftingComponents.push(slug);
                  } else {
                    console.log(`Component "${slug}" is still drifting. Issue ${issueNumber} needs to be updated.`);
                    componentsToUpdateIssues.push(slug);
                    driftingComponents.push(slug);
                  }
                } else {
                  console.log(`Component "${slug}" is not drifting anymore. Issue ${issueNumber} needs to be closed.`);
                  recoveredComponents.push(slug);
                }
              } else {
                console.log(`Component "${slug}" has been removed. Issue ${issueNumber} needs to be closed.`);
                removedComponents.push(slug);
              }
            } else {
              const drifted = componentsToStateMap[slug];

              if (drifted) {
                console.log(`Component "${slug}" drifted. New issue has to be created.`);
                componentsToCreateIssues.push(slug);
                driftingComponents.push(slug);
              } else {
                console.log(`Component "${slug}" is not drifting. Skipping ...`);
              }
            }
          }

          const componentsToCreateIssuesSerialized = JSON.stringify(componentsToCreateIssues);
          const componentsToUpdateIssuesSerialized = JSON.stringify(componentsToUpdateIssues);
          const removedComponentsSerialized = JSON.stringify(removedComponents);
          const recoveredComponentsSerialized = JSON.stringify(recoveredComponents);
          const driftingComponentsSerialized = JSON.stringify(driftingComponents);

          console.log(`components-to-create-issues: ${componentsToCreateIssuesSerialized}`);
          console.log(`components-to-update-issues: ${componentsToUpdateIssuesSerialized}`);
          console.log(`removed-components: ${removedComponentsSerialized}`);
          console.log(`recovered-components: ${recoveredComponentsSerialized}`);
          console.log(`drifting-components: ${driftingComponentsSerialized}`);

          core.setOutput('components-to-create-issues', componentsToCreateIssuesSerialized);
          core.setOutput('components-to-update-issues', componentsToUpdateIssuesSerialized);
          core.setOutput('removed-components', removedComponentsSerialized);
          core.setOutput('recovered-components', recoveredComponentsSerialized);
          core.setOutput('drifting-components', driftingComponentsSerialized);

    - name: Close Issues
      uses: actions/github-script@v6
      with:
        github-token: ${{ inputs.token }}
        script: |
          const componentsToIssuesMap = JSON.parse('${{ steps.drift-detection-issues.outputs.components-to-issues-map }}', 'utf8');
          const removedComponents = JSON.parse('${{ steps.triage.outputs.removed-components }}', 'utf8');
          const recoveredComponents = JSON.parse('${{ steps.triage.outputs.recovered-components }}', 'utf8');
          const componentsToCloseIssuesFor = removedComponents.concat(recoveredComponents);

          const repository = context.repo;

          for (let i = 0; i < componentsToCloseIssuesFor.length; i++) {
            const slug = componentsToCloseIssuesFor[i];
            const issueNumber = componentsToIssuesMap[slug];

            github.rest.issues.update({
              ...repository,
              issue_number: issueNumber,
              state: "closed"
            });

            github.rest.issues.addLabels({
              ...repository,
              issue_number: issueNumber,
              labels: ['drift-recovered']
            });

            github.rest.issues.createComment({
              ...repository,
              issue_number: issueNumber,
              body: removedComponents.hasOwnProperty(slug) ? `Component \`${slug}\` has been removed` : `Component \`${slug}\` is not drifting anymore`,
            });
          }

    - name: Create Issues
      uses: actions/github-script@v6
      id: create-issues
      with:
        github-token: ${{ inputs.token }}
        script: |
          const fs = require('fs');

          const repository = context.repo;
          const componentsToIssuesMap = JSON.parse('${{ steps.drift-detection-issues.outputs.components-to-issues-map }}', 'utf8');
          const componentsToCreateIssues = JSON.parse('${{ steps.triage.outputs.components-to-create-issues }}', 'utf8');
          const maxOpenedIssues = parseInt("${{ inputs.max-opened-issues }}", 10);
          const removedComponents = JSON.parse('${{ steps.triage.outputs.removed-components }}', 'utf8');
          const recoveredComponents = JSON.parse('${{ steps.triage.outputs.recovered-components }}', 'utf8');
          const numberOfIssuesToCreate = Math.max(0, maxOpenedIssues - (Object.keys(componentsToIssuesMap).length - removedComponents.length - recoveredComponents.length));
          const componentsToNewlyCreatedIssues = {};

          const issueLabels = "${{ inputs.issue-labels }}"
          const labels = issueLabels.split(",").map(item => item.trim()).filter(item => item != null && item !== "");

          for (let i = 0; i < numberOfIssuesToCreate; i++) {
            const slug = componentsToCreateIssues[i];
            const issueTitle = `Drift Detected in \`${slug}\``;
            const issueDescription = fs.readFileSync(`issue-description-${slug}.md`, 'utf8');
            
            const newIssue = await github.rest.issues.create({
              ...repository,
              title: issueTitle,
              body: issueDescription,
              labels: labels
            });

            const issueNumber = newIssue.data.number;

            componentsToNewlyCreatedIssues[slug] = issueNumber;

            console.log(`Created new issue with number: ${issueNumber}`);

            core.setOutput('issue-number', issueNumber);
          }

          const componentsToNewlyCreatedIssuesSerialized = JSON.stringify(componentsToNewlyCreatedIssues);

          console.log(`components-to-newly-created-issues: ${componentsToNewlyCreatedIssuesSerialized}`);

          core.setOutput('components-to-newly-created-issues', componentsToNewlyCreatedIssuesSerialized);

    - name: Update Issues
      uses: actions/github-script@v6
      with:
        github-token: ${{ inputs.token }}
        script: |
          const fs = require('fs');

          const componentsToUpdateIssues = JSON.parse('${{ steps.triage.outputs.components-to-update-issues }}', 'utf8');
          const componentsToIssuesMap = JSON.parse('${{ steps.drift-detection-issues.outputs.components-to-issues-map }}', 'utf8');

          const repository = context.repo;

          for (let i = 0; i < componentsToUpdateIssues.length; i++) {
            const slug = componentsToUpdateIssues[i];
            const issueDescription = fs.readFileSync(`issue-description-${slug}.md`, 'utf8');
            const issueNumber = componentsToIssuesMap[slug];

            github.rest.issues.update({
              ...repository,
              issue_number: issueNumber,
              body: issueDescription
            });

            console.log(`Updated issue: ${issueNumber}`);
          }

    - name: Post Drift Detection Summary
      uses: actions/github-script@v6
      with:
        github-token: ${{ inputs.token }}
        script: |
          const orgName = context.repo.owner;
          const repo = context.repo.repo;

          const componentsToIssuesMap = JSON.parse('${{ steps.drift-detection-issues.outputs.components-to-issues-map }}', 'utf8');
          const componentsToNewlyCreatedIssues = JSON.parse('${{ steps.create-issues.outputs.components-to-newly-created-issues }}', 'utf8');
          const componentsToCreateIssues = JSON.parse('${{ steps.triage.outputs.components-to-create-issues }}', 'utf8');
          const removedComponents = JSON.parse('${{ steps.triage.outputs.removed-components }}', 'utf8');
          const recoveredComponents = JSON.parse('${{ steps.triage.outputs.recovered-components }}', 'utf8');
          const driftingComponents = JSON.parse('${{ steps.triage.outputs.drifting-components }}', 'utf8');

          const table = [[{data: 'Component', header: true}, {data: 'State', header: true}, {data: 'Comments', header: true}]];

          for (let slug of Object.keys(componentsToNewlyCreatedIssues)) {
            const issueNumber = componentsToNewlyCreatedIssues[slug];

            table.push([`<pre>${slug}</pre>`, "DRIFTED", `Component drifted. Created new issue <a href="https://github.com/${orgName}/${repo}/issues/${issueNumber}">#${issueNumber}</a>`]);
          }

          for (let i = 0; i < componentsToCreateIssues.length; i++) {
            const slug = componentsToCreateIssues[i];

            if (!componentsToNewlyCreatedIssues.hasOwnProperty(slug)) {
              table.push([`<pre>${slug}</pre>`, "DRIFTED", `Component drifted. Issue was not created because maximum number of created issues ${{ inputs.max-opened-issues }} reached`]);
            }
          }

          for (let i = 0; i < removedComponents.length; i++) {
            const slug = removedComponents[i];
            const issueNumber = componentsToIssuesMap[slug];

            table.push([`<pre>${slug}</pre>`, "REMOVED", `Component was removed. Closed issue <a href="https://github.com/${orgName}/${repo}/issues/${issueNumber}">#${issueNumber}</a>`]);
          }

          for (let i = 0; i < recoveredComponents.length; i++) {
            const slug = recoveredComponents[i];
            const issueNumber = componentsToIssuesMap[slug];

            table.push([`<pre>${slug}</pre>`, "RECOVERED", `Component recovered. Closed issue <a href="https://github.com/${orgName}/${repo}/issues/${issueNumber}">#${issueNumber}</a>`]);
          }

          for (let i = 0; i < driftingComponents.length; i++) {
            const slug = driftingComponents[i];
            const issueNumber = componentsToIssuesMap[slug];

            if (!componentsToNewlyCreatedIssues.hasOwnProperty(slug)) {
              table.push([`<pre>${slug}</pre>`, "DRIFTED", `Component drifted. Issue already exists <a href="https://github.com/${orgName}/${repo}/issues/${issueNumber}">#${issueNumber}</a>`]);
            }
          }

          await core.summary
            .addHeading('Drift Detection Summary')
            .addTable(table)
            .write()

    - name: Post Step Summaries
      uses: actions/github-script@v6
      with:
        github-token: ${{ inputs.token }}
        script: |
          const fs = require('fs');

          const driftingComponents = JSON.parse('${{ steps.triage.outputs.drifting-components }}', 'utf8');

          for (let i = 0; i < driftingComponents.length; i++) {
            const slug = driftingComponents[i];
            const file = `step-summary-${slug}.md`;
            const content = fs.readFileSync(file, 'utf-8');

            await core.summary.addRaw(content).write();
          }

    # - name: Assign Issue to User and/or Teams
    #   uses: actions/github-script@v6
    #   if: env.ACTION == 'create-gh-issue'
    #   with:
    #     github-token: ${{ inputs.token }}
    #     script: |
    #       const assigneeTeams = "${{ inputs.assignee-teams }}";
    #       const assigneeUsers = "${{ inputs.assignee-users }}";

    #       function csvToArray(csvString) {
    #         return csvString
    #             .split(',')
    #             .map((item) => item.trim())
    #             .filter((item) => item !== '');
    #       }

    #       let teams = csvToArray(assigneeTeams);
    #       let users = csvToArray(assigneeUsers);

    #       if (teams.length === 0 && users.length === 0) {
    #         console.log("No users to assign issue with. Skipping ...");
    #         return;
    #       }

    #       const repository = context.repo;
    #       const orgName = context.repo.owner;
    #       const repo = context.repo.repo;
    #       const issueNumber = parseInt("${{ steps.create-issue.outputs.issue-number }}", 10);

    #       console.log(`${orgName}/${repo}`);

    #       let usersFromTeams = [];

    #       for (let i = 0; i < teams.length; i++) {
    #           const response = await github.rest.teams.listMembersInOrg({
    #             org: orgName,
    #             team_slug: teams[i]
    #           });

    #           const usersForCurrentTeam = response.data.map(user => user.login);
    #           usersFromTeams = usersFromTeams.concat(usersForCurrentTeam);
    #       }

    #       users = users.concat(usersFromTeams);
    #       users = [...new Set(users)]; // get unique set

    #       await github.rest.issues.addAssignees({
    #         ...repository,
    #         issue_number: issueNumber,
    #         assignees: users
    #       });
