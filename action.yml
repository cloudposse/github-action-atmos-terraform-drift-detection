name: 'GitHub Action Atmos Terraform Drift Detection'
description: 'GitHub Action Atmos Terraform Drift Detection'
author: hello@cloudposse.com
branding:
  icon: 'server'
  color: 'white'
inputs:
  issue-labels:
    description: "Comma separated list of labels to add to the drift issues. Default: drift"
    default: 'drift'
    required: false
  max-opened-issues:
    description: "Number of open drift detection issues. Use `-1` to open unlimited number of issues. Default: 10"
    default: '10'
    required: false
  assignee-users:
    description: "Comma-separated list of users to assign issues to. This is used only when issue is getting created."
    required: false
    default: ""
  assignee-teams:
    description: "Comma-separated list of teams to assign issues to. You have to pass github token with `read:org` scope. This is used only when issue is getting created."
    required: false
    default: ""
  debug:
    description: "Enable action debug mode. Default: false"
    default: 'false'
    required: false
  token:
    description:
      Used to pull node distributions for Atmos from Cloud Posse's GitHub repository. Since there's a default, this is typically
      not supplied by the user. When running this action on github.com, the default value is sufficient. When running on
      GHES, you can pass a personal access token for github.com if you are experiencing rate limiting.
    default: ${{ github.server_url == 'https://github.com' && github.token || '' }}

runs:
  using: "composite"
  steps:
    - name: Download Artifacts
      uses: actions/download-artifact@v3
      with:
        name: metadata

    - name: Get Drift Detection GitHub Issues
      id: drift-detection-issues
      uses: actions/github-script@v6
      with:
        github-token: ${{ inputs.token }}
        script: |
          const repository = context.repo;

          let per_page = 100; // Max allowed value per page
          let page = 1;
          let componentsToIssues = {};
          let componentsToMetadata = {};
          let isContinue = true;

          function getMetadataFromIssueBody(body) {
            const regex = /```json\s([\s\S]+?)\s```/;
            const matched = body.match(regex);

            if (matched && matched[1]) {
              return JSON.parse(matched[1]);
            } else {
              throw new Error("Invalid metadata in the issue description");
            }
          }

          while (isContinue) {
            const response = await github.rest.issues.listForRepo({
              ...repository,
              state: 'open',
              per_page,
              page
            });
            
            if (response.data.length === 0) {
              isContinue = false;
            } else {
              const driftDetectionIssues = response.data
                .filter(issue => issue.title.startsWith('Drift Detected in'));
              
              for (let issue of driftDetectionIssues) {
                const metadata = getMetadataFromIssueBody(issue.body);
                componentsToIssues[`${metadata.stack}-${metadata.component}`] = issue.number;
                componentsToMetadata[`${metadata.stack}-${metadata.component}`] = metadata;
              }

              page++;
            }
          }

          const componentsToIssuesSerialized = JSON.stringify(componentsToIssues);
          const componentsToMetadataSerialized = JSON.stringify(componentsToMetadata);

          console.log(`components-to-issues: ${componentsToIssuesSerialized}`);
          console.log(`components-to-metadata: ${componentsToMetadataSerialized}`);

          core.setOutput("components-to-issues", componentsToIssuesSerialized);
          core.setOutput("components-to-metadata", componentsToMetadataSerialized);

    - name: Read Metadata From Plan Artifacts
      id: metadata-from-artifacts
      uses: actions/github-script@v6
      with:
        github-token: ${{ inputs.token }}
        script: |
          const fs = require('fs');

          const files = fs.readdirSync('.');
          const metadataFiles = files.filter(file => file.endsWith('metadata.json'));

          let componentsToState = {};
          let componentsToMetadata = {};

          for (let i = 0; i < metadataFiles.length; i++) {
            console.log(`Processing file ${metadataFiles[i]}`);

            const metadata = JSON.parse(fs.readFileSync(metadataFiles[i], 'utf8'));

            const slug = `${metadata.stack}-${metadata.component}`;
            const drifted = metadata.drifted;

            componentsToState[slug] = drifted;
            componentsToMetadata[slug] = metadata;
          }

          const componentsToStateSerialized = JSON.stringify(componentsToState);
          const componentsToMetadataSerialized = JSON.stringify(componentsToMetadata);

          console.log(`Components to State Map: ${componentsToStateSerialized}`);
          console.log(`Components to Metadata Map: ${componentsToMetadataSerialized}`);

          core.setOutput("components-to-state", componentsToStateSerialized);
          core.setOutput("components-to-metadata", componentsToMetadataSerialized);

    - name: Triage
      id: triage
      uses: actions/github-script@v6
      with:
        github-token: ${{ inputs.token }}
        script: |
          const componentsToIssues = JSON.parse('${{ steps.drift-detection-issues.outputs.components-to-issues }}', 'utf8');
          const componentsToMetadata = JSON.parse('${{ steps.drift-detection-issues.outputs.components-to-metadata }}', 'utf8');
          const componentsToState = JSON.parse('${{ steps.metadata-from-artifacts.outputs.components-to-state }}', 'utf8');

          let slugs = new Set([...Object.keys(componentsToIssues), ...Object.keys(componentsToState)]);

          const componentsCandidatesToCreateIssue = [];
          const componentsCandidatesToCloseIssue = [];
          const componentsToUpdateExistingIssue = [];
          const removedComponents = [];
          const recoveredComponents = [];
          const driftingComponents = [];

          for (let slug of slugs) {
            if (componentsToIssues.hasOwnProperty(slug)) {
              const issueNumber = componentsToIssues[slug];

              if (componentsToState.hasOwnProperty(slug)) {
                const drifted = componentsToState[slug];

                if (drifted) {
                  const commitSHA = componentsToMetadata[slug].commitSHA;
                  const currentSHA = "${{ github.sha }}";
                  if (currentSHA === commitSHA) {
                    console.log(`Component "${slug}" marked as drifted but default branch SHA didn't change so nothing to update. Skipping ...`);
                    driftingComponents.push(slug);
                  } else {
                    console.log(`Component "${slug}" is still drifting. Issue ${issueNumber} needs to be updated.`);
                    componentsToUpdateExistingIssue.push(slug);
                    driftingComponents.push(slug);
                  }
                } else {
                  console.log(`Component "${slug}" is not drifting anymore. Issue ${issueNumber} needs to be closed.`);
                  componentsCandidatesToCloseIssue.push(slug);
                  recoveredComponents.push(slug);
                }
              } else {
                console.log(`Component "${slug}" has been removed. Issue ${issueNumber} needs to be closed.`);
                componentsCandidatesToCloseIssue.push(slug);
                removedComponents.push(slug);
              }
            } else {
              const drifted = componentsToState[slug];

              if (drifted) {
                console.log(`Component "${slug}" drifted. New issue has to be created.`);
                componentsCandidatesToCreateIssue.push(slug);
                driftingComponents.push(slug);
              } else {
                console.log(`Component "${slug}" is not drifting. Skipping ...`);
              }
            }
          }

          const componentsCandidatesToCreateIssueSerialized = JSON.stringify(componentsCandidatesToCreateIssue);
          const componentsToUpdateExistingIssueSerialized = JSON.stringify(componentsToUpdateExistingIssue);
          const removedComponentsSerialized = JSON.stringify(removedComponents);
          const recoveredComponentsSerialized = JSON.stringify(recoveredComponents);
          const driftingComponentsSerialized = JSON.stringify(driftingComponents);
          const componentsCandidatesToCloseIssueSerialized = JSON.stringify(componentsCandidatesToCloseIssue);

          console.log(`components-candidates-to-create-issue: ${componentsCandidatesToCreateIssueSerialized}`);
          console.log(`components-to-update-existing-issue: ${componentsToUpdateExistingIssueSerialized}`);
          console.log(`removed-components: ${removedComponentsSerialized}`);
          console.log(`recovered-components: ${recoveredComponentsSerialized}`);
          console.log(`drifting-components: ${driftingComponentsSerialized}`);
          console.log(`components-candidates-to-close-issue: ${componentsCandidatesToCloseIssueSerialized}`);

          core.setOutput('components-candidates-to-create-issue', componentsCandidatesToCreateIssueSerialized);
          core.setOutput('components-to-update-existing-issue', componentsToUpdateExistingIssueSerialized);
          core.setOutput('removed-components', removedComponentsSerialized);
          core.setOutput('recovered-components', recoveredComponentsSerialized);
          core.setOutput('drifting-components', driftingComponentsSerialized);
          core.setOutput('components-candidates-to-close-issue', componentsCandidatesToCloseIssueSerialized);

    - name: Close Issues
      uses: actions/github-script@v6
      with:
        github-token: ${{ inputs.token }}
        script: |
          const componentsToIssues = JSON.parse('${{ steps.drift-detection-issues.outputs.components-to-issues }}', 'utf8');
          const removedComponents = JSON.parse('${{ steps.triage.outputs.removed-components }}', 'utf8');
          const recoveredComponents = JSON.parse('${{ steps.triage.outputs.recovered-components }}', 'utf8');
          const componentsToCloseIssuesFor = removedComponents.concat(recoveredComponents);

          const repository = context.repo;

          for (let i = 0; i < componentsToCloseIssuesFor.length; i++) {
            const slug = componentsToCloseIssuesFor[i];
            const issueNumber = componentsToIssues[slug];

            github.rest.issues.update({
              ...repository,
              issue_number: issueNumber,
              state: "closed"
            });

            github.rest.issues.addLabels({
              ...repository,
              issue_number: issueNumber,
              labels: ['drift-recovered']
            });

            github.rest.issues.createComment({
              ...repository,
              issue_number: issueNumber,
              body: removedComponents.hasOwnProperty(slug) ? `Component \`${slug}\` has been removed` : `Component \`${slug}\` is not drifting anymore`,
            });
          }

    - name: Create Issues
      uses: actions/github-script@v6
      id: create-issues
      with:
        github-token: ${{ inputs.token }}
        script: |
          const fs = require('fs');

          const repository = context.repo;
          const orgName = context.repo.owner;
          const repo = context.repo.repo;
          const assigneeTeams = "${{ inputs.assignee-teams }}";
          const assigneeUsers = "${{ inputs.assignee-users }}";
          const componentsToIssues = JSON.parse('${{ steps.drift-detection-issues.outputs.components-to-issues }}', 'utf8');
          const componentsCandidatesToCreateIssue = JSON.parse('${{ steps.triage.outputs.components-candidates-to-create-issue }}', 'utf8');
          const componentsCandidatesToCloseIssue = JSON.parse('${{ steps.triage.outputs.components-candidates-to-close-issue }}', 'utf8');
          const maxOpenedIssues = parseInt("${{ inputs.max-opened-issues }}", 10);
          const removedComponents = JSON.parse('${{ steps.triage.outputs.removed-components }}', 'utf8');
          const recoveredComponents = JSON.parse('${{ steps.triage.outputs.recovered-components }}', 'utf8');
          const numberOfMaximumPotentialIssuesThatCanBeCreated = Math.max(0, maxOpenedIssues - Object.keys(componentsToIssues).length + componentsCandidatesToCloseIssue.length);
          const numOfIssuesToCreate = Math.min(numberOfMaximumPotentialIssuesThatCanBeCreated, componentsCandidatesToCreateIssue.length);
          const componentsToNewlyCreatedIssues = {};

          const issueLabels = "${{ inputs.issue-labels }}"
          const labels = issueLabels.split(",").map(item => item.trim()).filter(item => item != null && item !== "");

          function csvToArray(csvString) {
            return csvString
                .split(',')
                .map((item) => item.trim())
                .filter((item) => item !== '');
          }

          let teams = csvToArray(assigneeTeams);
          let users = csvToArray(assigneeUsers);

          if (teams.length === 0 && users.length === 0) {
            console.log("No users to assign issue with. Skipping ...");
          } else {
            try {
              let usersFromTeams = [];

              for (let i = 0; i < teams.length; i++) {
                  const response = await github.rest.teams.listMembersInOrg({
                    org: orgName,
                    team_slug: teams[i]
                  });

                  const usersForCurrentTeam = response.data.map(user => user.login);
                  usersFromTeams = usersFromTeams.concat(usersForCurrentTeam);
              }

              users = users.concat(usersFromTeams);
              users = [...new Set(users)]; // get unique set
            } catch (error) {
              core.error(`Failed to associate user to an issue. Error ${error.message}`);
              users = [];
            }
          }

          for (let i = 0; i < numOfIssuesToCreate; i++) {
            const slug = componentsCandidatesToCreateIssue[i];
            const issueTitle = `Drift Detected in \`${slug}\``;
            const issueDescription = fs.readFileSync(`issue-description-${slug}.md`, 'utf8');
            
            const newIssue = await github.rest.issues.create({
              ...repository,
              title: issueTitle,
              body: issueDescription,
              labels: labels
            });

            const issueNumber = newIssue.data.number;

            componentsToNewlyCreatedIssues[slug] = issueNumber;

            console.log(`Created new issue with number: ${issueNumber}`);

            core.setOutput('issue-number', issueNumber);

            if (users.size > 0) {
              try {
                await github.rest.issues.addAssignees({
                  ...repository,
                  issue_number: issueNumber,
                  assignees: users
                });
              } catch (error) {
                core.error(`Failed to associate user to an issue. Error ${error.message}`);
              }
            }
          }

          const componentsToNewlyCreatedIssuesSerialized = JSON.stringify(componentsToNewlyCreatedIssues);

          console.log(`components-to-newly-created-issues: ${componentsToNewlyCreatedIssuesSerialized}`);

          core.setOutput('components-to-newly-created-issues', componentsToNewlyCreatedIssuesSerialized);

    - name: Update Issues
      uses: actions/github-script@v6
      with:
        github-token: ${{ inputs.token }}
        script: |
          const fs = require('fs');

          const componentsToUpdateExistingIssue = JSON.parse('${{ steps.triage.outputs.components-to-update-existing-issue }}', 'utf8');
          const componentsToIssues = JSON.parse('${{ steps.drift-detection-issues.outputs.components-to-issues }}', 'utf8');

          const repository = context.repo;

          for (let i = 0; i < componentsToUpdateExistingIssue.length; i++) {
            const slug = componentsToUpdateExistingIssue[i];
            const issueDescription = fs.readFileSync(`issue-description-${slug}.md`, 'utf8');
            const issueNumber = componentsToIssues[slug];

            github.rest.issues.update({
              ...repository,
              issue_number: issueNumber,
              body: issueDescription
            });

            console.log(`Updated issue: ${issueNumber}`);
          }

    - name: Post Drift Detection Summary
      uses: actions/github-script@v6
      with:
        github-token: ${{ inputs.token }}
        script: |
          const orgName = context.repo.owner;
          const repo = context.repo.repo;

          const componentsToIssues = JSON.parse('${{ steps.drift-detection-issues.outputs.components-to-issues }}', 'utf8');
          const componentsToNewlyCreatedIssues = JSON.parse('${{ steps.create-issues.outputs.components-to-newly-created-issues }}', 'utf8');
          const componentsCandidatesToCreateIssue = JSON.parse('${{ steps.triage.outputs.components-candidates-to-create-issue }}', 'utf8');
          const removedComponents = JSON.parse('${{ steps.triage.outputs.removed-components }}', 'utf8');
          const recoveredComponents = JSON.parse('${{ steps.triage.outputs.recovered-components }}', 'utf8');
          const driftingComponents = JSON.parse('${{ steps.triage.outputs.drifting-components }}', 'utf8');

          const table = [[{data: 'Component', header: true}, {data: 'State', header: true}, {data: 'Comments', header: true}]];

          for (let slug of Object.keys(componentsToNewlyCreatedIssues)) {
            const issueNumber = componentsToNewlyCreatedIssues[slug];

            table.push([`<pre>${slug}</pre>`, "DRIFTED", `Component drifted. Created new issue <a href="https://github.com/${orgName}/${repo}/issues/${issueNumber}">#${issueNumber}</a>`]);
          }

          for (let i = 0; i < componentsCandidatesToCreateIssue.length; i++) {
            const slug = componentsCandidatesToCreateIssue[i];

            if (!componentsToNewlyCreatedIssues.hasOwnProperty(slug)) {
              table.push([`<pre>${slug}</pre>`, "DRIFTED", `Component drifted. Issue was not created because maximum number of created issues ${{ inputs.max-opened-issues }} reached`]);
            }
          }

          for (let i = 0; i < removedComponents.length; i++) {
            const slug = removedComponents[i];
            const issueNumber = componentsToIssues[slug];

            table.push([`<pre>${slug}</pre>`, "REMOVED", `Component has been removed. Closed issue <a href="https://github.com/${orgName}/${repo}/issues/${issueNumber}">#${issueNumber}</a>`]);
          }

          for (let i = 0; i < recoveredComponents.length; i++) {
            const slug = recoveredComponents[i];
            const issueNumber = componentsToIssues[slug];

            table.push([`<pre>${slug}</pre>`, "RECOVERED", `Component recovered. Closed issue <a href="https://github.com/${orgName}/${repo}/issues/${issueNumber}">#${issueNumber}</a>`]);
          }

          for (let i = 0; i < driftingComponents.length; i++) {
            const slug = driftingComponents[i];
            const issueNumber = componentsToIssues[slug];

            if (componentsCandidatesToCreateIssue.indexOf(slug) === -1) {
              table.push([`<pre>${slug}</pre>`, "DRIFTED", `Component drifted. Issue already exists <a href="https://github.com/${orgName}/${repo}/issues/${issueNumber}">#${issueNumber}</a>`]);
            }
          }

          await core.summary
            .addHeading('Drift Detection Summary')
            .addTable(table)
            .write()

    - name: Post Step Summaries
      uses: actions/github-script@v6
      with:
        github-token: ${{ inputs.token }}
        script: |
          const fs = require('fs');

          const driftingComponents = JSON.parse('${{ steps.triage.outputs.drifting-components }}', 'utf8');

          for (let i = 0; i < driftingComponents.length; i++) {
            const slug = driftingComponents[i];
            const file = `step-summary-${slug}.md`;
            const content = fs.readFileSync(file, 'utf-8');

            await core.summary.addRaw(content).write();
          }